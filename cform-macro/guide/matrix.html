<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 2.0.0 at $dateFormat.format( $currentDate ) 
 | Rendered using Apache Maven Fluido Skin 1.6
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="" lang="">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Language" content="" />
    <title>Matrix resources – CloudFormation macro processor.</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.6.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
      <script type="text/javascript" src="../js/apache-maven-fluido-1.6.min.js"></script>
      </head>
    <body class="topBarDisabled">
      <div class="container-fluid">
      <div id="banner">
        <div class="pull-left"><div id="bannerLeft"><h2>CloudFormation macro processor.</h2>
</div>
</div>
        <div class="pull-right"><a href="https://wrzasq.pl" id="bannerRight"><h2><img src="https://static.wrzasq.pl/images/wrzasqpl.png" alt="Wrzasq.pl"/></h2>
</a></div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
        </ul>
      </div>
      <div class="row-fluid">
        <div id="leftColumn" class="span2">
          <div class="well sidebar-nav">
<ul class="nav nav-list">
          <li class="nav-header">Main</li>
    <li><a href="https://github.com/rafalwrzeszcz-wrzasqpl/pl.wrzasq.cform/" class="externalLink" title="GitHub project"><span class="none"></span>GitHub project</a>  </li>
    <li><a href="https://wrzasq.pl/" class="externalLink" title="Wrzasq.pl"><span class="none"></span>Wrzasq.pl</a>  </li>
    <li><a href="https://www.facebook.com/wrzasqpl" class="externalLink" title="Wrzasq.pl @ Facebook"><span class="none"></span>Wrzasq.pl @ Facebook</a>  </li>
    <li><a href="https://www.linkedin.com/company/wrzasq-pl/" class="externalLink" title="Wrzasq.pl @ LinkedIn"><span class="none"></span>Wrzasq.pl @ LinkedIn</a>  </li>
          <li class="nav-header">Parent Project</li>
    <li><a href="../../index.html" title="WrzasqPl CForm"><span class="none"></span>WrzasqPl CForm</a>  </li>
          <li class="nav-header">Guide</li>
    <li><a href="../guide/deployment.html" title="Deployment"><span class="none"></span>Deployment</a>  </li>
    <li class="active"><a href="#"><span class="none"></span>Matrix resources</a>
  </li>
    <li><a href="../guide/apigateway.html" title="API Gateway"><span class="none"></span>API Gateway</a>  </li>
    <li><a href="../guide/codepipeline.html" title="CodePipeline"><span class="none"></span>CodePipeline</a>  </li>
    <li><a href="../guide/general.html" title="General improvements"><span class="none"></span>General improvements</a>  </li>
          <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a>  </li>
    <li><a href="../project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a>  </li>
  </ul>
          <hr />
          <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
  <a href="https://maven.apache.org/" title="Maven" class="builtBy"><img class="builtBy"  alt="Maven" src="../images/logos/maven-feather.png"    /></a>
<a href="https://wrzasq.pl" title="Wrzasq.pl" class="builtBy"><img class="builtBy"  alt="Wrzasq.pl" src="../images/logos/maven-feather.png"    /></a>
              </div>
          </div>
        </div>
        <div id="bodyColumn"  class="span10" >
<!---
# This file is part of the pl.wrzasq.cform.
#
# @license http://mit-license.org/ The MIT license
# @copyright 2023 © by Rafał Wrzeszcz - Wrzasq.pl.
-->
<section><a id="Matrix_resources"></a>
<h1>Matrix resources</h1>
<p>One of the major difficulties in creating flexible and re-usable <strong>CloudFormation</strong> template is lack of dynamic
resources creation, especially depending on some variable inputs. Using this macro one can specify matrix of variable
inputs for some resource, and it will be replicated for each variation expanding input template resource into multiple
resources dynamically (but in predictable way to avoid stack drifts and unnecessary infrastructure changes).</p><section><a id="Definition"></a>
<h2>Definition</h2>
<p>To turn resource definition into matrix resource simply add <code>Matrix</code> definition to it (note that unlike some other
&#x201c;major&#x201d; features of the macro, here we don't introduce any new section of the template - we operate directly within
<code>Resources</code> section):</p>

<pre><code class="language-yaml">Resources:
    TasksQueue:
        Type: &quot;AWS::SQS::Queue&quot;
        # this is it
        Matrix:
            Entries:
                # you can define multiple parameters - matrix will be generated for each combination
                Env:
                    Prod: &quot;prod01&quot;
                    Dev: &quot;dev&quot;
                Task:
                    Customers: &quot;customers&quot;
                    Order: &quot;orders-v2&quot;
        Properties:
            ContentBasedDeduplication: true
</code></pre>
<p>Declaration above will result in 4 resources in processed template:</p>
<ul>

<li><code>Prod</code> for <code>Customers</code></li>
<li><code>Prod</code> for <code>Orders</code></li>
<li><code>Dev</code> for <code>Customer</code></li>
<li><code>Dev</code> for <code>Orders</code></li>
</ul>
<p>There are different ways in which you can specify input values for some matrix parameter. It may be important to pick
one that fits not only your input definition structure, but also resources management pattern, as it affects how final
resources are organised in the template.</p>
<p>Each matrix variant is mapped using parameter key, which is obtained in different way depending on specified structure.</p>
<p>Each matrix entry value on the other hand can be used in properties resolution (will be described later).</p><section><a id="Dict"></a>
<h3>Dict</h3>
<p>A dictionary (map) is shown in the above example. Each entry has a key, which will be used in resource identification.
Mentioned example (simplified):</p>

<pre><code class="language-yaml">Resources:
    TasksQueue:
        Type: &quot;AWS::SQS::Queue&quot;
        Matrix:
            Entries:
                Env:
                    Prod: &quot;prod01&quot;
                    Dev: &quot;dev&quot;
</code></pre>
<p>Will result in having the following resources:</p>
<ul>

<li><code>TasksQueueProd</code></li>
<li><code>TasksQueueDev</code></li>
</ul></section><section><a id="List"></a>
<h3>List</h3>
<p>If only values are important for us (how to handle them will be described in next section) a list can be used:</p>

<pre><code class="language-yaml">Resources:
    TasksQueue:
        Type: &quot;AWS::SQS::Queue&quot;
        Matrix:
            Entries:
                Env:
                    - &quot;prod01&quot;
                    - &quot;dev&quot;
</code></pre>
<p>In case of list, key is a numeric index, so in this case we will have the following resources:</p>
<ul>

<li><code>TasksQueue0</code></li>
<li><code>TasksQueue1</code></li>
</ul>
<p>Important thing is that this way is essentially same mechanism as described below reference to a parameter, so it can be
used for mocking multiple resources before knowing particular input interface. Because logical IDs of final resources
are generated in predictable way, it can be later swapped without causing any changes in stack.</p></section><section><a id="Parameter_reference"></a>
<h3>Parameter reference</h3>
<p>The last way to define input values is referring to an input parameter. Parameter will be treated as a comma-separated
set of values (regardless of parameter type):</p>

<pre><code class="language-yaml">Parameters:
    Envs:
        # it doesn't matter, but of course you can use `CommaDelimitedList` for better visibility
        Type: &quot;String&quot;
        Default: &quot;dev,prod&quot;

Resources:
    TasksQueue:
        Type: &quot;AWS::SQS::Queue&quot;
        Matrix:
            Entries:
                Env: &quot;Envs&quot;
</code></pre>
<p><strong>Note:</strong> There is no <code>!Ref</code> call! Specifying single string results in resolving a parameter, defining <code>!Ref: &quot;Envs&quot;</code>
effectively passes a map.</p></section></section><section><a id="LogicalIdPattern"></a>
<h2>LogicalIdPattern</h2>
<p>Ok, so this is how we can define matrix of resources. But it's very important to understand how will it generate
results, as we are speaking about infrastructure - and especially CloudFormation is very sensitive to changes in
template structure or resource identifiers.</p>
<p>Each resource will have it's unique logical ID generated based on pattern, so it will be predictable and particular
entries in matrix should be identifiable. By default, each matrix parameter adds it's key to the pattern, so in our
initial example logical ID will have form of: <code>TasksQueue${Env}${Task}</code>. If you need different pattern, you can set it
using <code>LogicalIdPattern</code> property:</p>

<pre><code class="language-yaml">Resources:
    TasksQueue:
        Type: &quot;AWS::SQS::Queue&quot;
        Matrix:
            # here - note that there is no call it any CloudFormation function, like `!Sub`, this is resolved by macro
            # based on matrix definition, not stack parameters - you even can have a parameter named `Env` in the stack,
            # and it won't be affecting how logical IDs are generated
            LogicalIdPattern: &quot;QueueFor_${Env}&quot;
            Entries:
                Env:
                    Prod: &quot;prod01&quot;
                    Dev: &quot;dev&quot;
</code></pre>
<p>Example above will generate queues with logical IDs <code>QueueFor_Prod</code> and <code>QueueFor_Dev</code>.</p></section><section><a id="Substitutions"></a>
<h2>Substitutions</h2>
<p>Having resources identification handled we can move to second part - values resolving. Matrix definition would be most
likely useless without possibility to define values dependent on each option. When replicating matrix resources all
string values in <code>Properties</code> (that includes nested structures!) are processed looking for <code>${Each:}</code> references.</p>
<p><strong>Note:</strong> This is not a call to any CloudFormation function, it is done implicitly by macro on each string value. And
unlike logical ID, which is only used for static string generation, values within <code>Properties</code> may have calls to
functions, so we use <code>Each:</code> prefix to make it explicit.</p>
<p>Knowing that, let's try to enhance our example and define some tags for the queue:</p>

<pre><code class="language-yaml">Resources:
    TasksQueue:
        Type: &quot;AWS::SQS::Queue&quot;
        Matrix:
            Entries:
                Env:
                    Prod: &quot;prod01&quot;
                    Dev: &quot;dev&quot;
                Task:
                    Customers: &quot;customers&quot;
                    Order: &quot;orders-v2&quot;
        Properties:
            ContentBasedDeduplication: true
            Tags:
                -
                    Key: &quot;env&quot;
                    Value: &quot;${Each:Env}&quot;
                -
                    Key: &quot;id&quot;
                    # note the function call - it will remain and only ${Each:} placeholder will be pre-processed
                    Value: !Sub &quot;${AWS::AccountId}-${Each:Task}&quot;
</code></pre>
<p>Output will be as follows:</p>

<pre><code class="language-yaml">Resources:
    TasksQueueDevCustomers:
        Type: &quot;AWS::SQS::Queue&quot;
        Properties:
            ContentBasedDeduplication: true
            Tags:
                -
                    Key: &quot;env&quot;
                    Value: &quot;dev&quot;
                -
                    Key: &quot;id&quot;
                    Value: !Sub &quot;${AWS::AccountId}-customers&quot;

    TasksQueueDevOrder:
        Type: &quot;AWS::SQS::Queue&quot;
        Properties:
            ContentBasedDeduplication: true
            Tags:
                -
                    Key: &quot;env&quot;
                    Value: &quot;dev&quot;
                -
                    Key: &quot;id&quot;
                    Value: !Sub &quot;${AWS::AccountId}-orders-v2&quot;

    TasksQueueProdCustomers:
        Type: &quot;AWS::SQS::Queue&quot;
        Properties:
            ContentBasedDeduplication: true
            Tags:
                -
                    Key: &quot;env&quot;
                    Value: &quot;prod01&quot;
                -
                    Key: &quot;id&quot;
                    Value: !Sub &quot;${AWS::AccountId}-customers&quot;

    TasksQueueProdOrder:
        Type: &quot;AWS::SQS::Queue&quot;
        Properties:
            ContentBasedDeduplication: true
            Tags:
                -
                    Key: &quot;env&quot;
                    Value: &quot;prod01&quot;
                -
                    Key: &quot;id&quot;
                    Value: !Sub &quot;${AWS::AccountId}-orders-v2&quot;
</code></pre></section><section><a id="References"></a>
<h2>References</h2>
<p>Last part of this feature covers resolving references. Of course knowing particular ID patterns it would be possible to
write things like <code>!Ref: &quot;TasksQueueDevOrder&quot;</code>. But this way may be problematic if you suddenly change the pattern of
the ID. To make a reference to any matrix element you can use special notation (it will work in <code>Ref</code>, <code>Fn::GetAtt</code> and
<code>Fn::Sub</code> calls) - <code>Matrix:MatrixId[Param1=Key1,Param2=Key2]</code>. You can also add attribute name after dot - it will just
be kept for underlying replaced call.</p>
<p>Some examples:</p>
<ul>

<li><code>!Ref &quot;Matrix:TasksQueue[Env=Dev,Task=Customers]&quot;</code> will be replaced with <code>!Ref &quot;TasksQueueDevCustomers&quot;</code></li>
<li><code>!GetAtt &quot;Matrix:TasksQueue[Env=Prod,Task=Customers].Arn&quot;</code> will be replaced with <code>!GetAtt &quot;TasksQueueProdCustomers.Arn&quot;</code></li>
<li><code>!Sub &quot;Queue name is ${Matrix:TasksQueue[Env=Prod,Task=Order].QueueName}&quot;</code> will be replaced with <code>!Sub &quot;Queue name is ${TasksQueueProdOrder.QueueName}</code></li>
</ul>
<p>In many cases this structure can be over-verbose, but it can be used to reliably address always proper matrix entry.</p><section><a id="Length"></a>
<h3>Length</h3>
<p>Additionally, it's possible to also obtain size of the matrix by using <code>Fn::Length</code> call (keep in mind this function
requires
<a href="https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/intrinsic-function-reference-length.html" class="externalLink">AWS::LanguageExtension transform</a>
in your template). For that, a shortened notation without element selector is used - just <code>Matrix:MatrixId</code>:</p>

<pre><code class="language-yaml">Outputs:
    MatrixSize:
        Value:
            &quot;Fn::Length&quot;: &quot;Matrix:TasksQueue&quot;
</code></pre></section></section></section>
        </div>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &copy;2021&#x2013;${currentYear}
<a href="https://wrzasq.pl/">Rafał Wrzeszcz - Wrzasq.pl</a>.
All rights reserved.        <li id="publishDate" class="pull-right">$i18n.getString( "site-renderer", $locale, "template.lastpublished" ): $dateValue</li>
          <li id="projectVersion" class="pull-right">$i18n.getString( "site-renderer", $locale, "template.version" ): 1.4.20</li>
</p>
        </div>
        </div>
    </footer>
    </body>
</html>
